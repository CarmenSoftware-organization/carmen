<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Policy Engine Implementation Guide - Carmen ERP Documentation</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/marked-mermaid@latest/dist/css/marked-mermaid.min.css">
    <script src="https://cdn.jsdelivr.net/npm/marked@latest/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@latest/dist/mermaid.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #2563eb;
            --secondary: #64748b;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --bg-light: #f8fafc;
            --bg-white: #ffffff;
            --text-primary: #0f172a;
            --text-secondary: #64748b;
            --border: #e2e8f0;
            --shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background: var(--bg-light);
            color: var(--text-primary);
            line-height: 1.6;
            padding: 2rem;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .section-badge {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            background: var(--primary);
            color: white;
            border-radius: 0.375rem;
            font-size: 0.875rem;
            margin-bottom: 1rem;
        }

        .breadcrumb {
            color: var(--text-secondary);
            font-size: 0.875rem;
            margin-bottom: 1rem;
        }

        .breadcrumb a {
            color: var(--primary);
            text-decoration: none;
        }

        .breadcrumb a:hover {
            text-decoration: underline;
        }

        .back-link {
            display: inline-block;
            color: var(--primary);
            text-decoration: none;
            margin-bottom: 1rem;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        .content {
            background: var(--bg-white);
            padding: 2rem;
            border-radius: 0.75rem;
            box-shadow: var(--shadow);
        }

        h1 {
            font-size: 2rem;
            margin-bottom: 1rem;
            color: var(--text-primary);
        }

        h2 {
            font-size: 1.5rem;
            margin-top: 2rem;
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 2px solid var(--border);
            color: var(--text-primary);
        }

        h3 {
            font-size: 1.25rem;
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
            color: var(--text-primary);
        }

        h4 {
            font-size: 1.125rem;
            margin-top: 1rem;
            margin-bottom: 0.5rem;
            color: var(--text-primary);
        }

        p {
            margin-bottom: 1rem;
        }

        a {
            color: var(--primary);
            text-decoration: none;
        }

        a:hover {
            text-decoration: underline;
        }

        code {
            background: var(--bg-light);
            padding: 0.125rem 0.375rem;
            border-radius: 0.25rem;
            font-size: 0.875em;
            font-family: 'Monaco', 'Courier New', monospace;
        }

        pre {
            background: var(--text-primary);
            color: #f8fafc;
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            margin: 1rem 0;
        }

        pre code {
            background: none;
            padding: 0;
            color: inherit;
        }

        ul, ol {
            margin: 1rem 0;
            padding-left: 2rem;
        }

        li {
            margin: 0.5rem 0;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 1rem 0;
        }

        th, td {
            padding: 0.75rem;
            text-align: left;
            border: 1px solid var(--border);
        }

        th {
            background: var(--bg-light);
            font-weight: 600;
        }

        blockquote {
            border-left: 4px solid var(--primary);
            padding-left: 1rem;
            margin: 1rem 0;
            color: var(--text-secondary);
        }

        img {
            max-width: 100%;
            height: auto;
            border-radius: 0.5rem;
            margin: 1rem 0;
        }

        .mermaid {
            margin: 1.5rem 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="section-badge">Development</div>
        <div class="breadcrumb"><a href="../../index.html">Documentation</a> / <a href="../index.html">Development</a> / Policy Engine Implementation</div>
        <a href="../../index.html" class="back-link">← Back to Documentation Home</a>
        <div class="content" id="markdown-content"></div>
    </div>
    <script>
        const markdownContent = "# Policy Engine Implementation Guide\n\n## Table of Contents\n\n1. [Overview](#overview)\n2. [Architecture](#architecture)\n3. [Core Components](#core-components)\n4. [Implementation Guide](#implementation-guide)\n5. [Usage Examples](#usage-examples)\n6. [Testing Strategies](#testing-strategies)\n7. [Performance Optimization](#performance-optimization)\n8. [Debugging and Troubleshooting](#debugging-and-troubleshooting)\n9. [Best Practices](#best-practices)\n10. [API Reference](#api-reference)\n\n---\n\n## Overview\n\nThe Carmen ERP Policy Engine implements Attribute-Based Access Control (ABAC) to provide fine-grained, context-aware permission management. This guide covers everything developers need to know to implement, extend, and maintain the policy engine.\n\n### Key Features\n\n- **Attribute-Based Decisions**: Permissions based on Subject, Resource, Environment, and Action attributes\n- **Priority-Based Evaluation**: Policies evaluated in priority order (0-1000, higher first)\n- **Combining Algorithms**: Multiple strategies for resolving policy conflicts\n- **Expression Language**: Flexible rule definitions using 13 operators\n- **Caching Support**: Configurable caching for performance optimization\n- **Audit Logging**: Comprehensive decision tracking and compliance support\n\n### System Requirements\n\n- Node.js 20.14.0+\n- TypeScript 5.8.2+\n- Next.js 14+ (for web integration)\n- Zod for validation\n- Date-fns for temporal operations\n\n---\n\n## Architecture\n\n### High-Level Architecture\n\n```\n┌─────────────────────────────────────────────────────────────┐\n│                    Carmen ERP Application                   │\n├─────────────────────────────────────────────────────────────┤\n│  Access Request  │  Policy Management  │  User Interface   │\n├──────────────────┼─────────────────────┼───────────────────┤\n│                    Policy Engine Core                      │\n│  ┌─────────────┐  ┌──────────────────┐  ┌─────────────────┐ │\n│  │ Attribute   │  │ Policy Evaluator │  │ Decision Cache  │ │\n│  │ Provider    │  │                  │  │                 │ │\n│  └─────────────┘  └──────────────────┘  └─────────────────┘ │\n├─────────────────────────────────────────────────────────────┤\n│                    Data Layer                               │\n│  ┌─────────────┐  ┌──────────────────┐  ┌─────────────────┐ │\n│  │ Policies    │  │ Roles & Users    │  │ Audit Logs     │ │\n│  │ Store       │  │ Store            │  │ Store          │ │\n│  └─────────────┘  └──────────────────┘  └─────────────────┘ │\n└─────────────────────────────────────────────────────────────┘\n```\n\n### Data Flow\n\n```mermaid\nsequenceDiagram\n    participant App as Application\n    participant PE as Policy Engine\n    participant AP as Attribute Provider\n    participant PS as Policy Store\n    participant Cache as Decision Cache\n    participant Audit as Audit Logger\n\n    App->>PE: Access Request\n    PE->>Cache: Check cached decision\n    alt Cache Hit\n        Cache-->>PE: Cached decision\n        PE-->>App: Access decision\n    else Cache Miss\n        PE->>AP: Gather attributes\n        AP-->>PE: Subject/Resource/Environment attributes\n        PE->>PS: Fetch applicable policies\n        PS-->>PE: Policy list\n        PE->>PE: Evaluate policies\n        PE->>Cache: Store decision\n        PE->>Audit: Log decision\n        PE-->>App: Access decision\n    end\n```\n\n---\n\n## Core Components\n\n### 1. Policy Engine (`/lib/services/permissions/policy-engine.ts`)\n\nThe main orchestrator that coordinates policy evaluation.\n\n```typescript\nexport class PolicyEngine {\n  private config: PermissionSystemConfig;\n  private attributeProvider: AttributeProvider;\n  private policyStore: PolicyStore;\n  private decisionCache: DecisionCache;\n  private auditLogger: AuditLogger;\n\n  async evaluateAccess(request: AccessRequest): Promise<AccessDecision> {\n    // Implementation details below\n  }\n}\n```\n\n### 2. Attribute Provider\n\nResponsible for gathering contextual attributes for policy evaluation.\n\n```typescript\ninterface AttributeProvider {\n  getSubjectAttributes(userId: string): Promise<SubjectAttributes>;\n  getResourceAttributes(resourceId: string): Promise<ResourceAttributes>;\n  getEnvironmentAttributes(context: RequestContext): Promise<EnvironmentAttributes>;\n}\n```\n\n### 3. Policy Store\n\nManages policy persistence and retrieval.\n\n```typescript\ninterface PolicyStore {\n  findApplicablePolicies(\n    subject: SubjectAttributes,\n    resource: ResourceAttributes,\n    action: string\n  ): Promise<Policy[]>;\n  \n  getPolicy(policyId: string): Promise<Policy | null>;\n  createPolicy(policy: Policy): Promise<Policy>;\n  updatePolicy(policyId: string, updates: Partial<Policy>): Promise<Policy>;\n  deletePolicy(policyId: string): Promise<boolean>;\n}\n```\n\n---\n\n## Implementation Guide\n\n### Step 1: Initialize the Policy Engine\n\n```typescript\nimport { PolicyEngine } from '@/lib/services/permissions/policy-engine';\nimport { AttributeProvider } from '@/lib/services/permissions/attribute-provider';\nimport { PolicyStore } from '@/lib/services/permissions/policy-store';\n\n// Initialize dependencies\nconst attributeProvider = new AttributeProvider();\nconst policyStore = new PolicyStore();\n\n// Configure the engine\nconst config: PermissionSystemConfig = {\n  defaultCombiningAlgorithm: CombiningAlgorithm.DENY_OVERRIDES,\n  cacheEnabled: true,\n  cacheTTL: 300, // 5 minutes\n  auditEnabled: true,\n  auditLevel: 'decisions',\n  evaluationTimeout: 5000,\n  maxPolicyEvaluation: 100,\n  requireSecureConnection: true,\n  allowAnonymousAccess: false,\n  subscriptionRequired: true,\n  defaultSubscriptionLevel: 'basic'\n};\n\n// Create engine instance\nconst policyEngine = new PolicyEngine(config, attributeProvider, policyStore);\n```\n\n### Step 2: Create Policy Definitions\n\n```typescript\nimport { Policy, Rule, Expression, EffectType } from '@/lib/types/permissions';\n\n// Example: Department Manager can approve purchase requests under $5000\nconst departmentManagerPurchasePolicy: Policy = {\n  id: 'dept-mgr-purchase-approval',\n  name: 'Department Manager Purchase Approval',\n  description: 'Department managers can approve purchase requests under $5000',\n  priority: 700,\n  enabled: true,\n  effect: EffectType.PERMIT,\n  \n  target: {\n    subjects: [\n      {\n        attribute: 'role.name',\n        operator: Operator.EQUALS,\n        value: 'department-manager'\n      }\n    ],\n    resources: [\n      {\n        attribute: 'resourceType',\n        operator: Operator.EQUALS,\n        value: 'purchase_request'\n      }\n    ],\n    actions: ['approve'],\n    environment: [\n      {\n        attribute: 'isBusinessHours',\n        operator: Operator.EQUALS,\n        value: true\n      }\n    ]\n  },\n  \n  rules: [\n    {\n      id: 'amount-limit-rule',\n      description: 'Limit approval to requests under $5000',\n      condition: {\n        type: 'composite',\n        logicalOperator: LogicalOperator.AND,\n        expressions: [\n          {\n            type: 'simple',\n            attribute: 'totalValue.amount',\n            operator: Operator.LESS_THAN,\n            value: 5000\n          },\n          {\n            type: 'simple',\n            attribute: 'totalValue.currency',\n            operator: Operator.EQUALS,\n            value: 'USD'\n          },\n          {\n            type: 'simple',\n            attribute: 'documentStatus.stage',\n            operator: Operator.EQUALS,\n            value: 'pending_approval'\n          }\n        ]\n      }\n    }\n  ],\n  \n  obligations: [\n    {\n      id: 'audit-approval',\n      type: 'audit',\n      attributes: {\n        action: 'purchase_request_approved',\n        level: 'financial'\n      },\n      description: 'Log all purchase request approvals for financial audit'\n    }\n  ],\n  \n  version: '1.0.0',\n  createdBy: 'system',\n  createdAt: new Date(),\n  category: 'procurement',\n  tags: ['approval', 'purchase', 'financial']\n};\n```\n\n### Step 3: Implement Access Control in Your Application\n\n```typescript\n// In a Next.js API route or server action\nimport { PolicyEngine } from '@/lib/services/permissions/policy-engine';\nimport { getCurrentUser } from '@/lib/auth';\n\nexport async function approvePurchaseRequest(\n  purchaseRequestId: string\n): Promise<{ success: boolean; message: string }> {\n  try {\n    // Get current user context\n    const currentUser = await getCurrentUser();\n    if (!currentUser) {\n      return { success: false, message: 'Authentication required' };\n    }\n\n    // Create access request\n    const accessRequest: AccessRequest = {\n      userId: currentUser.id,\n      resourceId: purchaseRequestId,\n      action: 'approve',\n      resourceType: 'purchase_request',\n      source: 'web_app',\n      requestId: generateRequestId(),\n      timestamp: new Date()\n    };\n\n    // Evaluate access\n    const decision = await policyEngine.evaluateAccess(accessRequest);\n\n    if (decision.effect === EffectType.PERMIT) {\n      // Process the approval\n      await processPurchaseRequestApproval(purchaseRequestId);\n      \n      // Handle obligations\n      for (const obligation of decision.obligations) {\n        await processObligation(obligation, accessRequest);\n      }\n\n      return { success: true, message: 'Purchase request approved successfully' };\n    } else {\n      return { \n        success: false, \n        message: `Access denied: ${decision.reason}` \n      };\n    }\n\n  } catch (error) {\n    console.error('Error in purchase request approval:', error);\n    return { success: false, message: 'An error occurred during approval' };\n  }\n}\n```\n\n### Step 4: Create Custom Attribute Providers\n\n```typescript\nexport class CarmenAttributeProvider implements AttributeProvider {\n  \n  async getSubjectAttributes(userId: string): Promise<SubjectAttributes> {\n    // Fetch user data from your database\n    const user = await getUserById(userId);\n    const userRoles = await getUserRoles(userId);\n    const userDepartments = await getUserDepartments(userId);\n    \n    return {\n      // Identity\n      userId: user.id,\n      username: user.username,\n      email: user.email,\n      \n      // Organizational Structure\n      role: userRoles[0], // Primary role\n      roles: userRoles,\n      department: userDepartments[0], // Primary department\n      departments: userDepartments,\n      location: await getUserLocation(userId),\n      locations: await getUserLocations(userId),\n      \n      // Employment Details\n      employeeType: user.employeeType,\n      seniority: calculateSeniority(user.hireDate),\n      clearanceLevel: user.clearanceLevel,\n      \n      // Permissions & Capabilities\n      assignedWorkflowStages: await getAssignedWorkflowStages(userId),\n      delegatedAuthorities: await getDelegatedAuthorities(userId),\n      specialPermissions: await getSpecialPermissions(userId),\n      \n      // Status & Availability\n      accountStatus: user.status,\n      onDuty: await isUserOnDuty(userId),\n      shiftTiming: await getCurrentShiftTiming(userId),\n      \n      // Financial & Approval Limits\n      approvalLimit: user.approvalLimit,\n      budgetAccess: await getUserBudgetAccess(userId),\n      \n      // Session Context\n      currentSession: await getCurrentSession(userId)\n    };\n  }\n\n  async getResourceAttributes(resourceId: string): Promise<ResourceAttributes> {\n    // Implement resource attribute gathering\n    // This will vary based on your resource types\n    const resource = await getResourceById(resourceId);\n    \n    return {\n      resourceId: resource.id,\n      resourceType: resource.type,\n      resourceName: resource.name,\n      \n      // Ownership & Classification\n      owner: resource.ownerId,\n      ownerDepartment: resource.department,\n      ownerLocation: resource.location,\n      dataClassification: resource.classification,\n      \n      // Business Context\n      documentStatus: resource.status,\n      workflowStage: resource.currentStage,\n      approvalLevel: resource.approvalLevel,\n      priority: resource.priority,\n      \n      // Financial Context\n      totalValue: resource.totalValue,\n      budgetCategory: resource.budgetCategory,\n      costCenter: resource.costCenter,\n      \n      // Temporal Context\n      createdAt: resource.createdAt,\n      updatedAt: resource.updatedAt,\n      expiresAt: resource.expiresAt,\n      effectiveDate: resource.effectiveDate,\n      \n      // Compliance & Audit\n      requiresAudit: resource.requiresAudit,\n      regulatoryFlags: resource.regulatoryFlags,\n      retentionPeriod: resource.retentionPeriod,\n      complianceRequirements: resource.complianceRequirements,\n      \n      // Relationships\n      parentResource: resource.parentId,\n      relatedResources: resource.relatedIds,\n      dependencies: resource.dependencyIds,\n      \n      // Location Context\n      physicalLocation: resource.physicalLocation,\n      accessLocation: resource.accessLocation,\n      \n      // Custom attributes specific to your domain\n      customAttributes: resource.customData\n    };\n  }\n\n  async getEnvironmentAttributes(context: RequestContext): Promise<EnvironmentAttributes> {\n    const now = new Date();\n    \n    return {\n      // Temporal Context\n      currentTime: now,\n      dayOfWeek: now.toLocaleDateString('en-US', { weekday: 'long' }),\n      isBusinessHours: await isBusinessHours(now),\n      isHoliday: await isHoliday(now),\n      timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,\n      \n      // Location Context\n      requestIP: context.ip,\n      requestLocation: await getLocationFromIP(context.ip),\n      isInternalNetwork: await isInternalIP(context.ip),\n      facility: await getFacilityFromIP(context.ip),\n      country: await getCountryFromIP(context.ip),\n      region: await getRegionFromIP(context.ip),\n      \n      // Device & Session Context\n      deviceType: detectDeviceType(context.userAgent),\n      deviceId: context.deviceId,\n      userAgent: context.userAgent,\n      sessionId: context.sessionId,\n      authenticationMethod: context.authMethod,\n      sessionAge: calculateSessionAge(context.sessionStart),\n      \n      // System State\n      systemLoad: await getSystemLoad(),\n      maintenanceMode: await isMaintenanceMode(),\n      emergencyMode: await isEmergencyMode(),\n      systemVersion: process.env.APP_VERSION || '1.0.0',\n      \n      // Risk & Compliance Context\n      threatLevel: await getCurrentThreatLevel(),\n      complianceMode: await getActiveComplianceModes(),\n      auditMode: await isAuditMode(),\n      \n      // Request Context\n      requestMethod: context.method,\n      requestSource: detectRequestSource(context),\n      batchOperation: context.isBatch || false,\n      \n      // Custom environment attributes\n      customEnvironment: context.customAttributes || {}\n    };\n  }\n}\n```\n\n---\n\n## Usage Examples\n\n### Example 1: Simple Permission Check\n\n```typescript\n// Check if a user can view a purchase request\nasync function canViewPurchaseRequest(userId: string, purchaseRequestId: string): Promise<boolean> {\n  const request: AccessRequest = {\n    userId,\n    resourceId: purchaseRequestId,\n    action: 'read',\n    resourceType: 'purchase_request'\n  };\n\n  const decision = await policyEngine.evaluateAccess(request);\n  return decision.effect === EffectType.PERMIT;\n}\n```\n\n### Example 2: Batch Permission Checking\n\n```typescript\n// Check permissions for multiple resources at once\nasync function checkBulkPermissions(\n  userId: string,\n  resourceIds: string[],\n  action: string\n): Promise<Record<string, boolean>> {\n  const results: Record<string, boolean> = {};\n\n  // Create batch request\n  const batchRequest: AccessRequest = {\n    userId,\n    resourceId: 'batch',\n    action,\n    batchRequest: true,\n    batchItems: resourceIds.map(resourceId => ({\n      userId,\n      resourceId,\n      action,\n      resourceType: 'purchase_request'\n    }))\n  };\n\n  try {\n    const decision = await policyEngine.evaluateAccess(batchRequest);\n    \n    // Process batch results\n    if (decision.evaluatedPolicies) {\n      resourceIds.forEach((resourceId, index) => {\n        // Implementation depends on how batch results are structured\n        results[resourceId] = decision.effect === EffectType.PERMIT;\n      });\n    }\n\n    return results;\n  } catch (error) {\n    console.error('Batch permission check failed:', error);\n    // Return safe defaults\n    return resourceIds.reduce((acc, resourceId) => {\n      acc[resourceId] = false;\n      return acc;\n    }, {} as Record<string, boolean>);\n  }\n}\n```\n\n### Example 3: Context-Aware Permissions\n\n```typescript\n// Permission that considers time and location\nasync function canApproveOutsideHours(\n  userId: string,\n  purchaseRequestId: string,\n  emergencyReason?: string\n): Promise<{ allowed: boolean; obligations: Obligation[] }> {\n  const request: AccessRequest = {\n    userId,\n    resourceId: purchaseRequestId,\n    action: 'approve',\n    resourceType: 'purchase_request',\n    additionalAttributes: {\n      emergencyApproval: !!emergencyReason,\n      emergencyReason: emergencyReason\n    }\n  };\n\n  const decision = await policyEngine.evaluateAccess(request);\n  \n  return {\n    allowed: decision.effect === EffectType.PERMIT,\n    obligations: decision.obligations\n  };\n}\n```\n\n### Example 4: Dynamic Policy Creation\n\n```typescript\n// Create a temporary policy for special circumstances\nasync function createTemporaryApprovalPolicy(\n  userId: string,\n  resourceType: string,\n  expiresAt: Date,\n  reason: string\n): Promise<Policy> {\n  const tempPolicy: Policy = {\n    id: `temp-${userId}-${Date.now()}`,\n    name: `Temporary Approval - ${reason}`,\n    description: `Temporary approval policy for ${userId}`,\n    priority: 900, // High priority\n    enabled: true,\n    effect: EffectType.PERMIT,\n    \n    target: {\n      subjects: [\n        {\n          attribute: 'userId',\n          operator: Operator.EQUALS,\n          value: userId\n        }\n      ],\n      resources: [\n        {\n          attribute: 'resourceType',\n          operator: Operator.EQUALS,\n          value: resourceType\n        }\n      ],\n      actions: ['approve'],\n      environment: [\n        {\n          attribute: 'currentTime',\n          operator: Operator.LESS_THAN,\n          value: expiresAt.toISOString()\n        }\n      ]\n    },\n    \n    rules: [],\n    obligations: [\n      {\n        id: 'temp-policy-audit',\n        type: 'audit',\n        attributes: {\n          temporaryPolicy: true,\n          reason: reason,\n          grantedBy: 'system-admin'\n        }\n      }\n    ],\n    \n    version: '1.0.0',\n    createdBy: 'system',\n    createdAt: new Date(),\n    effectiveTo: expiresAt,\n    category: 'temporary',\n    tags: ['temporary', 'emergency']\n  };\n\n  // Store the policy\n  await policyStore.createPolicy(tempPolicy);\n  \n  return tempPolicy;\n}\n```\n\n---\n\n## Testing Strategies\n\n### Unit Testing\n\n```typescript\nimport { describe, it, expect, beforeEach } from 'vitest';\nimport { PolicyEngine } from '@/lib/services/permissions/policy-engine';\n\ndescribe('PolicyEngine', () => {\n  let policyEngine: PolicyEngine;\n  let mockAttributeProvider: jest.Mocked<AttributeProvider>;\n  let mockPolicyStore: jest.Mocked<PolicyStore>;\n\n  beforeEach(() => {\n    mockAttributeProvider = createMockAttributeProvider();\n    mockPolicyStore = createMockPolicyStore();\n    \n    const config: PermissionSystemConfig = {\n      defaultCombiningAlgorithm: CombiningAlgorithm.DENY_OVERRIDES,\n      cacheEnabled: false, // Disable cache for testing\n      auditEnabled: false,\n      evaluationTimeout: 1000,\n      maxPolicyEvaluation: 10\n    };\n\n    policyEngine = new PolicyEngine(config, mockAttributeProvider, mockPolicyStore);\n  });\n\n  describe('evaluateAccess', () => {\n    it('should permit access when policy allows', async () => {\n      // Arrange\n      const request: AccessRequest = {\n        userId: 'user-1',\n        resourceId: 'resource-1',\n        action: 'read'\n      };\n\n      mockAttributeProvider.getSubjectAttributes.mockResolvedValue({\n        userId: 'user-1',\n        role: { name: 'staff' },\n        // ... other attributes\n      });\n\n      mockPolicyStore.findApplicablePolicies.mockResolvedValue([\n        createPermitPolicy()\n      ]);\n\n      // Act\n      const decision = await policyEngine.evaluateAccess(request);\n\n      // Assert\n      expect(decision.effect).toBe(EffectType.PERMIT);\n      expect(decision.reason).toContain('Policy allows access');\n    });\n\n    it('should deny access when no applicable policies', async () => {\n      // Test implementation\n    });\n\n    it('should handle policy conflicts correctly', async () => {\n      // Test combining algorithms\n    });\n  });\n});\n```\n\n### Integration Testing\n\n```typescript\ndescribe('Policy Engine Integration', () => {\n  it('should enforce purchase request approval limits', async () => {\n    // Create test user with department manager role\n    const testUser = await createTestUser({\n      role: 'department-manager',\n      approvalLimit: { amount: 5000, currency: 'USD' }\n    });\n\n    // Create test purchase request\n    const purchaseRequest = await createTestPurchaseRequest({\n      totalValue: { amount: 3000, currency: 'USD' },\n      status: 'pending_approval'\n    });\n\n    // Test approval\n    const decision = await policyEngine.evaluateAccess({\n      userId: testUser.id,\n      resourceId: purchaseRequest.id,\n      action: 'approve'\n    });\n\n    expect(decision.effect).toBe(EffectType.PERMIT);\n\n    // Test with amount over limit\n    const expensiveRequest = await createTestPurchaseRequest({\n      totalValue: { amount: 8000, currency: 'USD' }\n    });\n\n    const deniedDecision = await policyEngine.evaluateAccess({\n      userId: testUser.id,\n      resourceId: expensiveRequest.id,\n      action: 'approve'\n    });\n\n    expect(deniedDecision.effect).toBe(EffectType.DENY);\n  });\n});\n```\n\n### Policy Testing Framework\n\n```typescript\nexport class PolicyTestFramework {\n  constructor(private policyEngine: PolicyEngine) {}\n\n  async testPolicy(\n    policy: Policy,\n    scenarios: PolicyTestScenario[]\n  ): Promise<PolicyTestResult[]> {\n    const results: PolicyTestResult[] = [];\n\n    for (const scenario of scenarios) {\n      try {\n        // Create evaluation context from scenario\n        const context: EvaluationContext = {\n          subject: scenario.subjectAttributes,\n          resource: scenario.resourceAttributes,\n          environment: scenario.environmentAttributes,\n          action: scenario.action,\n          requestId: generateTestRequestId(),\n          timestamp: new Date(),\n          source: 'test'\n        };\n\n        // Evaluate policy\n        const decision = await this.policyEngine.evaluatePolicyAgainstContext(\n          policy,\n          context\n        );\n\n        // Check if result matches expectation\n        const passed = decision.effect === scenario.expectedResult;\n\n        results.push({\n          scenarioId: scenario.id,\n          scenarioName: scenario.name,\n          passed,\n          actualResult: decision.effect,\n          expectedResult: scenario.expectedResult,\n          reason: decision.reason,\n          executionTime: decision.evaluationTime\n        });\n\n      } catch (error) {\n        results.push({\n          scenarioId: scenario.id,\n          scenarioName: scenario.name,\n          passed: false,\n          actualResult: 'ERROR',\n          expectedResult: scenario.expectedResult,\n          reason: error.message,\n          error: error\n        });\n      }\n    }\n\n    return results;\n  }\n}\n\n// Usage\nconst testFramework = new PolicyTestFramework(policyEngine);\nconst results = await testFramework.testPolicy(departmentManagerPolicy, [\n  {\n    id: 'scenario-1',\n    name: 'Department manager approves small purchase',\n    subjectAttributes: { role: 'department-manager', /* ... */ },\n    resourceAttributes: { totalValue: { amount: 1000, currency: 'USD' } },\n    environmentAttributes: { isBusinessHours: true },\n    action: 'approve',\n    expectedResult: EffectType.PERMIT\n  },\n  {\n    id: 'scenario-2',\n    name: 'Department manager approves large purchase',\n    subjectAttributes: { role: 'department-manager' },\n    resourceAttributes: { totalValue: { amount: 10000, currency: 'USD' } },\n    environmentAttributes: { isBusinessHours: true },\n    action: 'approve',\n    expectedResult: EffectType.DENY\n  }\n]);\n```\n\n---\n\n## Performance Optimization\n\n### Caching Strategy\n\n```typescript\nexport class PolicyDecisionCache {\n  private cache: Map<string, CachedDecision> = new Map();\n  private ttl: number;\n\n  constructor(ttlSeconds: number = 300) {\n    this.ttl = ttlSeconds * 1000;\n  }\n\n  private generateCacheKey(request: AccessRequest): string {\n    // Create deterministic cache key\n    const keyParts = [\n      request.userId,\n      request.resourceId,\n      request.action,\n      request.resourceType || '',\n      // Include relevant environment factors\n      Math.floor(Date.now() / (this.ttl / 4)) // Quarter TTL buckets for time-sensitive decisions\n    ];\n\n    return keyParts.join(':');\n  }\n\n  async get(request: AccessRequest): Promise<AccessDecision | null> {\n    const key = this.generateCacheKey(request);\n    const cached = this.cache.get(key);\n\n    if (!cached) {\n      return null;\n    }\n\n    // Check expiration\n    if (Date.now() > cached.expiresAt) {\n      this.cache.delete(key);\n      return null;\n    }\n\n    // Update access time for LRU tracking\n    cached.lastAccessed = Date.now();\n    return cached.decision;\n  }\n\n  async set(request: AccessRequest, decision: AccessDecision): Promise<void> {\n    const key = this.generateCacheKey(request);\n    const cached: CachedDecision = {\n      decision,\n      createdAt: Date.now(),\n      expiresAt: Date.now() + this.ttl,\n      lastAccessed: Date.now(),\n      accessCount: 1\n    };\n\n    this.cache.set(key, cached);\n\n    // Periodic cleanup\n    if (this.cache.size > 10000) {\n      await this.cleanup();\n    }\n  }\n\n  private async cleanup(): Promise<void> {\n    const now = Date.now();\n    const entries = Array.from(this.cache.entries());\n\n    // Remove expired entries\n    const validEntries = entries.filter(([_, cached]) => cached.expiresAt > now);\n\n    // If still too many, remove least recently used\n    if (validEntries.length > 8000) {\n      validEntries.sort(([_, a], [__, b]) => b.lastAccessed - a.lastAccessed);\n      validEntries.splice(8000);\n    }\n\n    // Rebuild cache\n    this.cache.clear();\n    validEntries.forEach(([key, cached]) => {\n      this.cache.set(key, cached);\n    });\n  }\n}\n```\n\n### Policy Optimization\n\n```typescript\nexport class PolicyOptimizer {\n  \n  // Pre-compile policies for faster evaluation\n  static compilePolicies(policies: Policy[]): CompiledPolicy[] {\n    return policies.map(policy => ({\n      ...policy,\n      compiledRules: policy.rules.map(rule => this.compileRule(rule)),\n      fastTargetCheck: this.compileTargetCheck(policy.target)\n    }));\n  }\n\n  private static compileRule(rule: Rule): CompiledRule {\n    return {\n      ...rule,\n      evaluator: this.compileExpression(rule.condition)\n    };\n  }\n\n  private static compileExpression(expression: Expression): ExpressionEvaluator {\n    // Create optimized evaluation function\n    if (expression.type === 'simple') {\n      return this.compileSimpleExpression(expression);\n    } else {\n      return this.compileCompositeExpression(expression);\n    }\n  }\n\n  // Index policies by common attributes for faster lookup\n  static createPolicyIndex(policies: Policy[]): PolicyIndex {\n    const index: PolicyIndex = {\n      byResourceType: new Map(),\n      byAction: new Map(),\n      bySubjectRole: new Map(),\n      byPriority: policies.sort((a, b) => (b.priority || 500) - (a.priority || 500))\n    };\n\n    policies.forEach(policy => {\n      // Index by resource types mentioned in target\n      policy.target.resources?.forEach(condition => {\n        if (condition.attribute === 'resourceType') {\n          const resourceType = String(condition.value);\n          if (!index.byResourceType.has(resourceType)) {\n            index.byResourceType.set(resourceType, []);\n          }\n          index.byResourceType.get(resourceType)!.push(policy);\n        }\n      });\n\n      // Index by actions\n      policy.target.actions?.forEach(action => {\n        if (!index.byAction.has(action)) {\n          index.byAction.set(action, []);\n        }\n        index.byAction.get(action)!.push(policy);\n      });\n\n      // Index by subject roles\n      policy.target.subjects?.forEach(condition => {\n        if (condition.attribute === 'role.name' || condition.attribute === 'role') {\n          const role = String(condition.value);\n          if (!index.bySubjectRole.has(role)) {\n            index.bySubjectRole.set(role, []);\n          }\n          index.bySubjectRole.get(role)!.push(policy);\n        }\n      });\n    });\n\n    return index;\n  }\n}\n```\n\n---\n\n## Debugging and Troubleshooting\n\n### Debug Mode\n\n```typescript\nexport class PolicyEngineDebugger {\n  private debug: boolean = false;\n  private traceLog: DebugEntry[] = [];\n\n  enableDebug(): void {\n    this.debug = true;\n    this.traceLog = [];\n  }\n\n  disableDebug(): void {\n    this.debug = false;\n  }\n\n  trace(phase: string, data: any): void {\n    if (!this.debug) return;\n\n    this.traceLog.push({\n      timestamp: Date.now(),\n      phase,\n      data: JSON.parse(JSON.stringify(data)), // Deep clone\n      memory: process.memoryUsage(),\n      duration: performance.now()\n    });\n  }\n\n  getDebugReport(): DebugReport {\n    if (!this.debug) {\n      throw new Error('Debug mode not enabled');\n    }\n\n    return {\n      totalEntries: this.traceLog.length,\n      totalDuration: this.traceLog[this.traceLog.length - 1]?.duration || 0,\n      phases: this.groupByPhase(),\n      entries: this.traceLog\n    };\n  }\n\n  async debugEvaluateAccess(request: AccessRequest): Promise<{\n    decision: AccessDecision;\n    debug: DebugReport;\n  }> {\n    this.enableDebug();\n    \n    try {\n      this.trace('request_received', { request });\n      \n      const decision = await this.policyEngine.evaluateAccess(request);\n      \n      this.trace('decision_made', { decision });\n      \n      return {\n        decision,\n        debug: this.getDebugReport()\n      };\n    } finally {\n      this.disableDebug();\n    }\n  }\n}\n\n// Usage\nconst debugger = new PolicyEngineDebugger(policyEngine);\nconst { decision, debug } = await debugger.debugEvaluateAccess(request);\n\nconsole.log('Decision:', decision);\nconsole.log('Debug info:');\ndebug.phases.forEach(phase => {\n  console.log(`  ${phase.name}: ${phase.duration}ms (${phase.entries} entries)`);\n});\n```\n\n### Common Issues and Solutions\n\n#### Issue 1: Policies Not Applying\n\n**Symptoms:**\n- Expected PERMIT but got DENY\n- Policy seems correct but doesn't match\n\n**Debugging Steps:**\n```typescript\n// Check if policy target matches\nconst context = await gatherEvaluationContext(request);\nconst targetMatches = await evaluatePolicyTarget(policy, context);\nconsole.log('Target matches:', targetMatches);\n\n// Check individual target conditions\npolicy.target.subjects?.forEach((condition, index) => {\n  const result = evaluateCondition(condition, context.subject);\n  console.log(`Subject condition ${index}:`, condition, 'Result:', result);\n});\n```\n\n**Common Causes:**\n- Attribute names don't match exactly (case sensitivity)\n- Wrong operator usage (e.g., `EQUALS` vs `CONTAINS`)\n- Missing or incorrect attribute values\n- Policy disabled or expired\n\n#### Issue 2: Performance Problems\n\n**Symptoms:**\n- Slow response times\n- High memory usage\n- Timeout errors\n\n**Solutions:**\n```typescript\n// Add performance monitoring\nconst startTime = performance.now();\nconst decision = await policyEngine.evaluateAccess(request);\nconst endTime = performance.now();\n\nif (endTime - startTime > 1000) {\n  console.warn('Slow policy evaluation:', {\n    duration: endTime - startTime,\n    request,\n    policiesEvaluated: decision.evaluatedPolicies?.length\n  });\n}\n\n// Optimize with indexing\nconst policyIndex = PolicyOptimizer.createPolicyIndex(allPolicies);\nconst applicablePolicies = policyIndex.findApplicable(request);\n```\n\n#### Issue 3: Cache Issues\n\n**Symptoms:**\n- Stale decisions\n- Permissions not updating immediately\n- Inconsistent behavior\n\n**Debugging:**\n```typescript\n// Check cache status\nconst cacheKey = cache.generateCacheKey(request);\nconst cached = await cache.get(request);\n\nconsole.log('Cache status:', {\n  key: cacheKey,\n  hit: !!cached,\n  age: cached ? Date.now() - cached.createdAt : null\n});\n\n// Force cache refresh\nawait cache.invalidate(request);\nconst freshDecision = await policyEngine.evaluateAccess(request);\n```\n\n---\n\n## Best Practices\n\n### 1. Policy Design Principles\n\n**Keep Policies Simple and Focused**\n```typescript\n// ❌ Bad: Complex policy doing multiple things\nconst complexPolicy = {\n  // Multiple unrelated conditions and effects\n};\n\n// ✅ Good: Simple, focused policy\nconst simplePolicy = {\n  name: 'Department Manager Purchase Approval Under 5K',\n  // Single, clear purpose with well-defined conditions\n};\n```\n\n**Use Descriptive Names and Documentation**\n```typescript\nconst policy: Policy = {\n  name: 'Department Manager Purchase Approval - Standard Limit',\n  description: 'Allows department managers to approve purchase requests under $5000 during business hours. Requires audit logging for financial compliance.',\n  // Clear explanation of what, who, when, and why\n};\n```\n\n**Implement Proper Priority Management**\n```typescript\n// Priority ranges by policy type\nconst PRIORITY_RANGES = {\n  EMERGENCY_OVERRIDE: 950-999,   // Emergency policies\n  DENY_POLICIES: 800-949,        // Security denials\n  SPECIFIC_PERMITS: 600-799,     // Specific role permissions  \n  GENERAL_PERMITS: 400-599,      // General permissions\n  DEFAULT_POLICIES: 200-399,     // Default behaviors\n  FALLBACK: 0-199               // Fallback policies\n};\n```\n\n### 2. Performance Best Practices\n\n**Optimize Attribute Gathering**\n```typescript\n// ❌ Bad: Gather all attributes always\nasync getSubjectAttributes(userId: string): Promise<SubjectAttributes> {\n  // Expensive operations even when not needed\n  const everything = await gatherAllPossibleAttributes(userId);\n  return everything;\n}\n\n// ✅ Good: Lazy loading based on policy requirements\nasync getSubjectAttributes(\n  userId: string, \n  requiredAttributes?: string[]\n): Promise<SubjectAttributes> {\n  const base = await getBaseAttributes(userId);\n  \n  if (requiredAttributes?.includes('approvalLimit')) {\n    base.approvalLimit = await getApprovalLimit(userId);\n  }\n  \n  if (requiredAttributes?.includes('shiftTiming')) {\n    base.shiftTiming = await getCurrentShiftTiming(userId);\n  }\n  \n  return base;\n}\n```\n\n**Use Efficient Policy Storage**\n```typescript\n// Store frequently used policies in memory\nclass OptimizedPolicyStore {\n  private hotPolicies = new Map<string, Policy>();\n  private policyIndex = new Map<string, string[]>();\n\n  async findApplicablePolicies(\n    subject: SubjectAttributes,\n    resource: ResourceAttributes,\n    action: string\n  ): Promise<Policy[]> {\n    // Fast path: check indexed policies first\n    const candidateIds = this.findCandidatePolicies(resource.resourceType, action);\n    const candidates = candidateIds.map(id => this.hotPolicies.get(id)).filter(Boolean);\n    \n    if (candidates.length > 0) {\n      return this.filterApplicable(candidates, subject, resource, action);\n    }\n    \n    // Slow path: database query\n    return await this.queryDatabase(subject, resource, action);\n  }\n}\n```\n\n### 3. Security Best Practices\n\n**Implement Secure Defaults**\n```typescript\nconst secureConfig: PermissionSystemConfig = {\n  defaultCombiningAlgorithm: CombiningAlgorithm.DENY_OVERRIDES, // Secure default\n  requireSecureConnection: true,\n  allowAnonymousAccess: false,\n  auditEnabled: true,\n  auditLevel: 'all',\n  evaluationTimeout: 5000, // Prevent DoS\n  maxPolicyEvaluation: 100  // Limit complexity\n};\n```\n\n**Validate All Inputs**\n```typescript\nimport { z } from 'zod';\n\nconst accessRequestSchema = z.object({\n  userId: z.string().min(1).max(100),\n  resourceId: z.string().min(1).max(100),\n  action: z.string().min(1).max(50),\n  resourceType: z.string().optional(),\n  source: z.string().optional(),\n  additionalAttributes: z.record(z.any()).optional()\n});\n\nexport async function evaluateAccess(\n  request: unknown\n): Promise<AccessDecision> {\n  // Validate input\n  const validRequest = accessRequestSchema.parse(request);\n  \n  // Sanitize strings\n  const sanitizedRequest = sanitizeAccessRequest(validRequest);\n  \n  return await policyEngine.evaluateAccess(sanitizedRequest);\n}\n```\n\n**Log Security Events**\n```typescript\nclass SecurityAuditLogger {\n  async logAccessDecision(\n    request: AccessRequest,\n    decision: AccessDecision,\n    context: EvaluationContext\n  ): Promise<void> {\n    const auditEvent = {\n      timestamp: new Date(),\n      eventType: 'ACCESS_DECISION',\n      userId: request.userId,\n      resourceId: request.resourceId,\n      action: request.action,\n      decision: decision.effect,\n      reason: decision.reason,\n      sourceIP: context.environment.requestIP,\n      userAgent: context.environment.userAgent,\n      sessionId: context.environment.sessionId,\n      policies: decision.evaluatedPolicies.map(p => p.policyId),\n      riskScore: this.calculateRiskScore(request, decision, context)\n    };\n\n    await this.writeAuditLog(auditEvent);\n    \n    // Alert on high-risk events\n    if (auditEvent.riskScore > 0.8) {\n      await this.sendSecurityAlert(auditEvent);\n    }\n  }\n}\n```\n\n### 4. Testing Best Practices\n\n**Use Test Data Builders**\n```typescript\nexport class PolicyTestBuilder {\n  private policy: Partial<Policy> = {\n    priority: 500,\n    enabled: true,\n    effect: EffectType.PERMIT\n  };\n\n  static create(): PolicyTestBuilder {\n    return new PolicyTestBuilder();\n  }\n\n  withName(name: string): PolicyTestBuilder {\n    this.policy.name = name;\n    return this;\n  }\n\n  withPriority(priority: number): PolicyTestBuilder {\n    this.policy.priority = priority;\n    return this;\n  }\n\n  forResource(resourceType: string): PolicyTestBuilder {\n    this.policy.target = {\n      ...this.policy.target,\n      resources: [\n        {\n          attribute: 'resourceType',\n          operator: Operator.EQUALS,\n          value: resourceType\n        }\n      ]\n    };\n    return this;\n  }\n\n  forRole(role: string): PolicyTestBuilder {\n    this.policy.target = {\n      ...this.policy.target,\n      subjects: [\n        {\n          attribute: 'role.name',\n          operator: Operator.EQUALS,\n          value: role\n        }\n      ]\n    };\n    return this;\n  }\n\n  build(): Policy {\n    return {\n      id: `test-${Date.now()}`,\n      version: '1.0.0',\n      createdBy: 'test',\n      createdAt: new Date(),\n      ...this.policy\n    } as Policy;\n  }\n}\n\n// Usage\nconst testPolicy = PolicyTestBuilder\n  .create()\n  .withName('Test Department Manager Policy')\n  .withPriority(700)\n  .forRole('department-manager')\n  .forResource('purchase_request')\n  .build();\n```\n\n---\n\n## API Reference\n\n### PolicyEngine Class\n\n```typescript\nclass PolicyEngine {\n  constructor(\n    config: PermissionSystemConfig,\n    attributeProvider: AttributeProvider,\n    policyStore: PolicyStore,\n    cache?: DecisionCache,\n    auditLogger?: AuditLogger\n  )\n\n  // Main evaluation method\n  async evaluateAccess(request: AccessRequest): Promise<AccessDecision>\n  \n  // Batch evaluation\n  async evaluateBatch(requests: AccessRequest[]): Promise<AccessDecision[]>\n  \n  // Policy testing\n  async testPolicy(policy: Policy, scenarios: PolicyTestScenario[]): Promise<PolicyTestResult[]>\n  \n  // Cache management\n  async clearCache(pattern?: string): Promise<void>\n  async getCacheStats(): Promise<CacheStats>\n  \n  // Configuration\n  updateConfig(updates: Partial<PermissionSystemConfig>): void\n  getConfig(): PermissionSystemConfig\n}\n```\n\n### Key Types\n\n```typescript\n// Core request type\ninterface AccessRequest {\n  userId: string;\n  resourceId: string;\n  action: string;\n  resourceType?: string;\n  additionalAttributes?: Record<string, any>;\n  source?: string;\n  requestId?: string;\n  timestamp?: Date;\n  batchRequest?: boolean;\n  batchItems?: AccessRequest[];\n}\n\n// Decision response\ninterface AccessDecision {\n  effect: EffectType;\n  reason: string;\n  obligations: Obligation[];\n  advice: Advice[];\n  requestId: string;\n  evaluatedPolicies: PolicyResult[];\n  evaluationTime: number;\n  cacheHit: boolean;\n  timestamp: Date;\n  evaluatedBy: string;\n  auditRequired: boolean;\n  confidenceLevel?: number;\n}\n\n// Policy definition\ninterface Policy {\n  id: string;\n  name: string;\n  description: string;\n  priority: number;\n  enabled: boolean;\n  target: PolicyTarget;\n  rules: Rule[];\n  effect: EffectType;\n  obligations?: Obligation[];\n  advice?: Advice[];\n  version: string;\n  createdBy: string;\n  createdAt: Date;\n  updatedBy?: string;\n  updatedAt?: Date;\n  tags?: string[];\n  category?: string;\n  effectiveFrom?: Date;\n  effectiveTo?: Date;\n  testScenarios?: PolicyTestScenario[];\n  validationRules?: string[];\n}\n```\n\n---\n\n## Conclusion\n\nThis implementation guide provides a comprehensive foundation for working with the Carmen ERP Policy Engine. The ABAC system offers powerful, flexible permission management that can adapt to complex business requirements while maintaining security and performance.\n\n### Next Steps\n\n1. **Start with Simple Policies**: Begin with basic RBAC-style policies and gradually add attribute-based conditions\n2. **Implement Comprehensive Testing**: Use the testing framework to validate all policies\n3. **Monitor Performance**: Use the debugging and performance monitoring tools in production\n4. **Iterate and Improve**: Regularly review policy effectiveness and optimize based on usage patterns\n\n### Additional Resources\n\n- [ABAC Architecture Decision Record](/docs/architecture/adr-003-abac-permission-system.md)\n- [Permission Management Todos](/docs/permission-management-todos.md)\n- [Type Definitions](/lib/types/permissions.ts)\n- [Policy Engine Source](/lib/services/permissions/policy-engine.ts)\n\nFor questions or issues, please refer to the project documentation or create an issue in the repository.";

        // Initialize mermaid
        mermaid.initialize({
            startOnLoad: true,
            theme: 'default'
        });

        // Configure marked
        marked.setOptions({
            highlight: function(code, lang) {
                return code;
            },
            breaks: true,
            gfm: true
        });

        // Render markdown
        document.getElementById('markdown-content').innerHTML = marked.parse(markdownContent);

        // Render mermaid diagrams
        mermaid.contentLoaded();
    </script>
</body>
</html>